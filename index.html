<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="index.css" rel="stylesheet">
  <title>Path finding</title>
</head>

<body>
  <nav class="menu">
    <div class="links">
      <ul>
        <li>Mazes</li>
      </ul>
    </div>
    <div class="logo">
      <span>Algorythm</span>
    </div>
  </nav>
  <div class="container">
    <div class="content">
      <h1>Mazes</h1>
      <hr />
      <div class="textbox">
        <p>
          A maze is a path, or collection of paths, that tipically lead from an entrance to a goal.
          Mazes have been a widely studied topic in Computer Science, with many algorithms
          dedicated to building and solving them. Various data structures can represent mazes and labyrinths,
          like graphs, trees and, in the case of Algorythm, bidimensional arrays - or matrixes.
        </p>
        <div class="static_mazes">
          <!-- HERE IS THE THREE SAMPLE MAZES `drawings/sampleMazes.js`-->
        </div>
        <p>
          Here, I will show in detail some of this algorithms to generate random mazes and
          find a path to solve them.
        </p>
      </div>
      <br />
      <h2>Recursive Backtrack</h2>
      <div class="textbox">
        <p>
          Backtracking is a sort of refined brute force used to be a selective graph traversal method.
          Imagine a graph/tree representing a initial position (the root node) and a final goal
          (one of the leaves), and we want to find this leave. So, we could brute-force the
          nodes and paths until reach the goal, but depending on the graph weight a raw brute-force approach
          would explode into an impossible number of choices to consider and inviabilize our task. It is the kind
          of situation where the recursive backtracking becomes useful.
        </p>
        <br />
        <p>
          Using backtracking, at each node we can eliminate bad choices that are obviously the wrong answer
          and proceed to recursively check only those that have potential. This way, at each depth of
          the tree, we mitigate the number of choices to consider in the future.
        </p>
        <br />
        <p>
          Suppose you get to a bad leaf. You can backtrack to continue the search for a good leaf
          by revoking your most recent choice, and trying out the next option in that set of options.
          If you run out of options, revoke the choice that got you here, and try another choice at
          that node. If you end up at the root with no options left, there are no good leaves to be found.
        </p>
        <br />
        <p>
          Backtracking is very useful for solving trivial problems like Sudoku, crosswords and queens.
          However, here we will use Recursive Backtrack for a more restricted problem: generate randomic mazes.
        </p>
        <br />
        <p>
          By choosing random directions and building "bridges" between nodes, the Backtracking is one of the most
          simpler methods to generate mazes. It works in this steps:
        </p>
        <br />
        <ol>
          <li>Start a bidimensional array where all nodes are walls;</li>
          <li>Choose a root node as start point and make it a path;</li>
          <li>
            Randomly choose a direction to pick a neighbor node. Check if it hasn't already been visited
            (check if the node is a wall);
          </li>
          <li>
            Move two units (nodes) in that direction, setting both the forward node and the link node to paths;
          </li>
          <li>Call the function recursively with the new forward node's (x,y) coordinates;</li>
          <li>
            Repeat until reach a dead end;
            <ul>
              <li>If during step three you found that all of your directions contained paths, you need to backtrack;
              </li>
              <li>
                To backtrack, we are going to exit the current function call. This means we are moving backwards
                into the previous function which had initially moved us into this current node until we find a path.
                Once we find a new path, we go to step three.
              </li>
            </ul>
          </li>
        </ol>
        <p>
          Let's draw step by step to help understand this algorithm:
        </p>
        <br />
        <div class="flexbox">
          <div id="backtrack_steps">
            <!-- HERE IS THE BACKTRACKING STEPS -->
          </div>
        </div>
        <br />
        <div class="textbox">
          <p>Well, now you can play and test the algorithm generating random mazes:</p>
        </div>
      </div>
      <div id="canvas"></div>
    </div>
  </div>
  <footer></footer>

  <script src="utils.js"></script>
  <script src="Maze.js"></script>
  <script src="algorithms/aStar.js"></script>
  <script src="algorithms/Prims.js"></script>
  <script src="algorithms/RecursiveBacktrack.js"></script>

  <script src="drawings/sampleMazes.js"></script>
  <script src="drawings/backtrackingSteps.js"></script>
  <script src="app.js"></script>
</body>

</html>