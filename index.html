<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="index.css" rel="stylesheet">
  <title>Path finding</title>
</head>

<body>
  <nav class="menu">
    <div class="links">
      <ul>
        <li>Mazes</li>
      </ul>
    </div>
    <div class="logo">
      <span>Algorythm</span>
    </div>
  </nav>
  <div class="container">
    <div class="content">
      <h1>Mazes</h1>
      <hr />
      <div class="textbox">
        <p>
          A maze is a path, or collection of paths, that tipically lead from an entrance to a goal.
          Mazes have been a widely studied topic in Computer Science, with many algorithms
          dedicated to building and solving them. Various data structures can represent mazes and labyrinths,
          like graphs, trees and, in the case of Algorythm, bidimensional arrays - or matrixes.
        </p>
        <div class="static_mazes">
          <!-- HERE IS THE THREE SAMPLE MAZES `drawings/sampleMazes.js`-->
        </div>
        <p>
          Here, I will show in detail some of this algorithms to generate random mazes and
          find a path to solve them.
        </p>
      </div>
      <br />
      <h2>Recursive Backtrack</h2>
      <div class="textbox">
        <p>
          Backtracking is a sort of refined brute force used to be a selective graph traversal method.
          Imagine a graph/tree representing a initial position (the root node) and a final goal
          (one of the leaves), and we want to find this leave. So, we could brute-force the
          nodes and paths until reach the goal, but depending on the graph weight a raw brute-force approach
          would explode into an impossible number of choices to consider and inviabilize our task. It is the kind
          of situation where the recursive backtracking becomes useful.
        </p>
        <br />
        <p>
          Using backtracking, at each node we can eliminate bad choices that are obviously the wrong answer
          and proceed to recursively check only those that have potential. This way, at each depth of
          the tree, we mitigate the number of choices to consider in the future.
        </p>
        <br />
        <p>
          Suppose you get to a bad leaf. You can backtrack to continue the search for a good leaf
          by revoking your most recent choice, and trying out the next option in that set of options.
          If you run out of options, revoke the choice that got you here, and try another choice at
          that node. If you end up at the root with no options left, there are no good leaves to be found.
        </p>
        <br />
        <p>
          Backtracking is very useful for solving trivial problems like Sudoku, crosswords and queens.
          However, here we will use Recursive Backtrack for a more restricted problem: generate randomic mazes.
        </p>
        <br />
        <p>
          By choosing random directions and building "bridges" between nodes, the Backtracking is one of the most
          simpler methods to generate mazes. It works in these steps:
        </p>
        <br />
        <ol>
          <li>Start a bidimensional array where all nodes are walls;</li>
          <li>Choose a root node as start point and make it a path;</li>
          <li>
            Randomly choose a direction to pick a neighbor node. Check if it hasn't already been visited
            (check if the node is a wall);
          </li>
          <li>
            Move two units (nodes) in that direction, setting both the forward node and the link node to paths;
          </li>
          <li>Call the function recursively with the new forward node's (x,y) coordinates;</li>
          <li>
            Repeat until reach a dead end;
            <ul>
              <li>If during step three you found that all of your directions contained paths, you need to backtrack;
              </li>
              <li>
                To backtrack, we are going to exit the current function call. This means we are moving backwards
                into the previous function which had initially moved us into this current node until we find a path.
                Once we find a new path, we go to step three.
              </li>
            </ul>
          </li>
        </ol>
        <p>
          Let's draw step by step to help understand this algorithm:
        </p>
        <br />
        <div class="flexbox">
          <div id="backtrack_steps">
            <!-- HERE IS THE BACKTRACKING STEPS -->
          </div>
        </div>
        <br />
        <div class="textbox">
          <p>Here is a sample maze generated using Recursive Backtracking: </p>
        </div>
        <br />
      </div>
      <div class="flexbox">
        <div class="test_canvas">
          <form onsubmit="submitMaze(event, 0, 'backtrack')">
            <div class="controls_content">
              <select name="maze_size" class="size_select">
                <option value="50">10x10</option>
                <option value="25">20x20</option>
                <option value="20" selected="selected">25x25</option>
                <option value="10">50x50</option>
              </select>
              <label for="maze_size">Maze size</label>
            </div>
            <div class="controls_content">
              <input type="checkbox" class="show_grid" name="grid" value="false">
              <label for="grid">Show grid</label>
            </div>
            <input type="submit" value="New maze">
          </form>
        </div>
      </div>
      <br />
      <h2>Prim's Algorithm</h2>
      <div class="textbox">
        <p>
          The other algorithm for maze generation that I will show here is the Prim's algorithm.
          Prim's is a greedy algorithm that finds a minimum spanning tree for a undirected graph.
          In other words, the algorithm finds a subgraph from the main graph where the total
          weight of all the edges in the tree is minimized and all vertex are connected.
        </p>
        <br />
        <p>
          The Prim's algorithm was developed in 1930 by Czech mathematician Vojtěch Jarník - just to emphasize,
          the first eletronic computer was built in 1942 - and later rediscovered and republished
          by computer scientists Robert C. Prim in 1957 (that gives name to it) and Edsger W. Dijkstra (another
          scientist well known for his algorithms) in 1959.
        </p>
        <br />
        <p>
          To simplify, lets analyse a practical example. Imagine five cities connected by dirt roads, like
          in the first figure of the graph below (buildings are cities and dashed lines are roads, the numbers are the
          length of the road). So, we want to pave the roads in a way that all cities are interconnected using the least
          amount of asphalt possible. This is exactly the kind of problem that Prim's algorithm becomes useful, once it
          finds the shorter path that connect all vertices. If we apply the algorithm in this problem, the result is
          in the next sequence (the orange city is the source vertice, where the algorithm starts, and the red edges
          are the paved roads).
        </p>
        <br />
        <div class="flexbox">
          <img src="assets/prims-graph.png" />
        </div>
        <br />
        <p>
          But, the example above is for graphs. Here we are working with bidimensional matrixes, and the algorithm
          needed some adaptation to work for this purpouse. So, if the Prim's use is connect vertices through edges, we
          can also use it to generate randomic mazes. In fact, it is a simple algorithm, these are the steps I followed
          to program it:
        </p>
        <br />
        <ol>
          <li>Start with a bidimensional array full of cells in state Blocked (walls).</li>
          <li>
            Pick a source cell, set it to state Passage and compute its frontier cells. A frontier
            cell of a Cell is a cell with distance 2 in state Blocked and within the grid.
          </li>
          <li>
            While the list of frontier cells is not empty:
            <ol>
              <li>Pick a random frontier cell from the list of frontier cells.</li>
              <li>
                Get all neighbors from this frontier cell. A neighbor from a cell are all cells in distance
                2 in state Passage and within the grid.
              </li>
              <li>
                Pick a random neighbor and connect the frontier cell with the neighbor by setting
                the cell in-between to state Passage.
              </li>
              <li>Compute the frontier cells of the chosen frontier cell and add them to the frontier list.</li>
              <li>Remove the chosen frontier cell from the list of frontier cells.</li>
            </ol>
          </li>
          <ul>
            <li>A Cell (node) has 2 states: Blocked or Passage.</li>
            <li>We use 2 for distance because we need to consider the walls as a integer cell of the grid</li>
          </ul>
        </ol>
        <br />
        <p>
          Now, we can see the Prim's generating random mazes in practice:
        </p>
        <div class="flexbox">
          <div class="test_canvas">
            <form onsubmit="submitMaze(event, 1, 'prims')">
              <div class="controls_content">
                <select name="maze_size" class="size_select">
                  <option value="50">10x10</option>
                  <option value="25">20x20</option>
                  <option value="20" selected="selected">25x25</option>
                  <option value="10">50x50</option>
                </select>
                <label for="maze_size">Maze size</label>
              </div>
              <div class="controls_content">
                <input type="checkbox" class="show_grid" name="grid" value="false">
                <label for="grid">Show grid</label>
              </div>
              <input type="submit" value="New maze">
            </form>
          </div>
        </div>
      </div>
    </div>
  </div>
  <footer></footer>

  <script src="utils.js"></script>
  <script src="Maze.js"></script>
  <script src="algorithms/aStar.js"></script>
  <script src="algorithms/Prims.js"></script>
  <script src="algorithms/RecursiveBacktrack.js"></script>

  <script src="drawings/sampleMazes.js"></script>
  <script src="drawings/backtrackingSteps.js"></script>
  <script src="app.js"></script>
</body>

</html>